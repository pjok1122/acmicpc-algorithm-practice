'''
[문제 풀기에 앞서 생각할 것]

1. 공유기 사이의 간격을 최대가 되도록 하는 문제.
2. '간격'을 Binary Search를 이용해서 찾아 나간다.
3. 공유기의 갯수가 많을 수록 간격은 좁아지며, 반대로 공유기의 갯수가 적을 수록 간격은 넓어진다.

[B.S 알고리즘]

문제의 예시처럼 1,2,4,8,9 라는 좌표가 주어졌을 때를 생각해보자.

최소 간격은 1이고, 최대 간격은 8이다.

따라서 1~8 사이에 우리가 원하는 정답이 있다.

B.S를 적용하기 위해 mid = (1+8)/2 --> 4 로 설정하자. 이는, 가장 가까운 집 사이의 간격이 4가 되도록 공유기를 설치하겠다는 의미이다.

따라서 공유기를 직접 설치하는 알고리즘이 필요하다.

[공유기 설치 알고리즘]

예시 :[1,2,4,8,9]

1. 가장 먼저 Base Case로 1이라는 위치에 공유기를 설치해놓는다.
2. 2라는 위치에 공유기를 설치하면 간격이 1이 되므로 설치하지 않는다.
3. 4라는 위치에 공유기를 설치하면 간격이 3가 되므로 설치하지 않는다.
4. 8이라는 위치에 공유기를 설치하면 간격이 7이 되므로 설치한다.
5. 9라는 위치에 공유기를 설치하면 간격이 1이 되므로 설치하지 않는다.     ** 간격 : 9-8
----------------------------------------------------------------------------------

이 공유기 설치 알고리즘이 끝나고 나면, 공유기의 갯수를 파악한다.
만약, 공유기의 갯수가 C보다 작다면 공유기의 '간격(mid)'을 더 작게(촘촘하게) 설치해야 한다.
반대로, 공유기의 갯수가 C보다 크다면, 공유기의 '간격(mid)'을 좀 더 크게 설치할 수 있다.
잘 생각해보면, 공유기의 갯수가 C와 일치하더라도, 공유기의 '간격(mid)'을 좀 더 크게 설치해볼 필요성이 있다.

설치되는 공유기의 갯수가 C보다 크거나 같을 때 모두 정답이 될 수 있으므로, ans라는 변수에 계속 대입해주는 것이 좋다.

이 과정을 코드로 작성하면 다음과 같다.
'''

import sys

N,C = map(int, sys.stdin.readline().split())
home = [int(sys.stdin.readline()) for _ in range(N)]

home.sort()

# 공유기 사이의 간격을 넘겨줬을 때, 공유기의 개수를 반환하는 함수.
def routerInstall(distance):
    count = 1
    cur_home = home[0]      #공유기가 설치된 집.
    for i in range(1,N):
        if (distance <= home[i] - cur_home):    #공유기를 설치하고자 하는 집과의 간격이 더 크기 때문에 공유기 설치 가능.
            count+=1
            cur_home = home[i]
    
    return count
            
# 공유기의 갯수를 넘겨줬을 때, 적절한 간격을 찾아주는 함수.
def BinarySearch(target):
    start = 1
    end = home[-1] - home[0]     #가장 멀리있는 집 사이의 거리

    while(start<=end):
        mid = (start+end)//2
        router_cnt = routerInstall(mid)
        if router_cnt < target:     #공유기의 갯수가 모자라면, 목표 간격을 좁힌다.
            end = mid - 1
        elif router_cnt >= target:  # 공유기를 목표치 이상으로 설치할 수 있다면, 정답이 될 수 있음.
            answer = mid
            start = mid + 1
    
    return answer



print(BinarySearch(C))