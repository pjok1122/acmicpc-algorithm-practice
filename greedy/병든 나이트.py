'''
[문제 풀기 전에 생각할 것]

나이트의 움직임을 잘 살펴보면, 왼쪽으로 움직일 수가 없다.
따라서 매 회 오른쪽으로 1,2칸 씩 움직이게 되고, 가로의 길이에 도달하면 더 이상 움직일 수 없다.
즉, 오른쪽으로 1칸 씩 움직이게 만드는 것이 최선의 전략이라고 할 수 있다.

하지만 오른쪽으로 1칸씩 움직이려면, 체스판의 높이가 적어도 3이 되어야 한다.
즉, 체스판의 높이가 1인지, 2인지, 3이상인지로 나눠 계산한다. 

[알고리즘]

1. 체스판의 높이가 1인 경우
    - 움직일 수 있는 경우가 없으므로 1을 반환

2. 체스판의 높이가 2인 경우
    - (→→↑) (→→↓)로 움직일 수 있다. 너비의 길이에 따라 횟수가 달라질 수 있다.
    - 한 번에 2칸씩 이동하므로 횟수는 (width+1)//2가 된다.
    - 하지만 4번 이상의 이동 제약을 만족시킬 수 없기 때문에, 최대 4를 갖는다.
    - 정답 : min(4,(width+1)//2)

3. 체스판의 높이가 3이상인 경우
    - 가장 먼저 모든 방향으로 1번씩 이동할 수 있는지를 파악해야 한다.
    - 모든 방향으로 1번씩 이동하면, (→→↑), (→→↓), (→↑↑), (→↓↓) 이므로 오른쪽으로 6칸 이동한다. 즉 너비가 7이상이어야 한다.
    
    1) 너비가 7보다 작은 경우
        - (→↑↑), (→↓↓) 이렇게 움직이는 것이 최고의 전략이다.
        - 문제의 조건 상 4번 이상 움직일 수 없으므로 정답은 4 이하다.
        - 정답 : min(4, width)
    
    2) 너비가 7보다 큰 경우
        - 4회 이상 움직일 수 있으므로 미리 조건대로 움직인다. (→→↑), (→→↓), (→↑↑), (→↓↓)
        - 그 이후로는 (→↑↑), (→↓↓) 이렇게 움직이는 것이 최고의 전략이다.
        - 정답 : width-2
        - 이유 : 처음부터 (→↑↑), (→↓↓) 반복으로 움직이면 정답은 width인데,
                (→→↑), (→→↓) 이동 때문에 불필요하게 오른쪽으로 2칸을 더 움직였기 때문에 -2를 한다.
        - 예시: 높이 : 3, 너비 : 10으로 그려볼 것.
'''


height,width = map(int, input().split())

def knightMove():
    if height==1:
        return 1
    elif height==2:
        return min(4,(width+1)//2)      #4회 제약조건 | (→→↑), (→→↓) Move
    
    if width<7:
        return min(4,width)             #4회 제약조건 | (→↑↑), (→↓↓) Move
    else:
        return width-2                  #4회 제약조건 & (→↑↑), (→↓↓) Move

print(knightMove()) 