'''
겹치지 않게 최대한 많은 회의 수를 찾는 문제.

[시작시간, 끝나는 시간] 으로 이루어져있다고 했을 때, 회의 시간이 겹치지 않게 구성해야 한다.
만약, 회의 시간이 [1,4] , [3,5]인 두 회의가 있다고 하면, 3~4시는 회의가 겹치기 때문에 참석할 수 없다.

자, 그럼 여러 회의가 있을 때, 어떤 회의를 선택해야 할까?

최대한 많은 회의를 하기 위해서는 반드시 일찍 끝나는 회의를 진행하는 것이 좋다.
일찍 끝나는 회의란, `절대 시간`이 짧은 회의를 의미하는 것이지, 회의 시간의 길이를 의미하는 것이 아니다.

즉, [1,4], [3,5] 두 회의가 있다면 4시에 끝나는 1번 회의를 선택하는 것이 좋다.
그 이유를 뒷받침할 근거로, [4,5]라는 회의가 추가된다면 이해가 될 것이다.

이 문제는 회의의 시작시간과 끝나는 시간이 같을 수 있기 때문에 한 가지 조건이 더 필요하다.

예를 들어, 회의가 [1,1],[1,2],[2,2] 라고 했을 때, 끝나는 시간만으로 정렬할 경우

discuss = [[1,1],[2,2],[1,2]] 가 될 수있고, 우리는 회의의 수를 2라고 출력하게 된다.
따라서 회의의 시작 시간에 대해서도 정렬이 필요하다.

즉, discuss =[[1,1],[1,2],[2,2]] 로 정렬되어있어야, 올바른 회의 수를 카운트할 수 있다.

[알고리즘]
1. 회의가 끝나는 시간으로 회의를 정렬한다.
2. 각 회의를 탐색하면서 회의를 선택할 수 있는지를 파악한다. (이전에 선택한 회의와 겹치는지 파악)

'''
import sys
N = int(sys.stdin.readline())
discuss = [list(map(int,sys.stdin.readline().split())) for _ in range(N)]

# 1. 정렬
discuss.sort(key=lambda x: (x[1], x[0]))
cnt = 0
time_now = -1
# 일찍 끝나는 회의 선택.
for diss in discuss:
    if diss[0]>=time_now: #회의 시작 시간 >= 현재 시간
        time_now = diss[1]
        cnt+=1

print(cnt)