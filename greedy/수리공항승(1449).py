'''
[문제 풀기 전 생각할 것]

테이프를 붙일 때, 결국 왼쪽 오른쪽 0.5씩 여백을 줘야하기 때문에 한 번에 수리가 가능한 길이는 L-1이다.

예를 들어,

파이프 위치가 [1,2,3,4,10,15,20] 으로 주어지고, 테이프의 길이가 4라고 하자.

pipe[1]-pipe[0] = 2-1 = 1 이므로 테이프의 길이-1인 3보다 작다. 따라서 pipe[0], pipe[1]은 한 번에 수리가 가능하다.
pipe[2]-pipe[1] = 3-1 = 2 이므로 테이프의 길이-1인 3보다 작다. 따라서 pipe[0], pipe[1], pipe[2]는 한 번에 수리가 가능하다.

이렇게 문제 풀이를 생각했다.

이 방법이 안되는 것은 아니지만, 더 간단하게 생각해볼 수 있다.

테이프의 길이가 4라는 사실은 변함이 없기 때문에, '1'이라는 위치에서 테이프를 붙이면, '4'라는 위치까지는 한 번에 수리가 가능하다.
즉, 4보다 작은 숫자에 대해서는 탐색할 필요가 없다.

이 방법은 앞 뒤 간격을 계산할 필요가 없기 때문에 구현하는 데에 있어서 훨씬 간단하다.

[알고리즘]

예시 : [1,2,3,5,10,15,20], 4

1. 현재 위치를 1로 정의한다.
2. 현재 위치에서 테이프를 붙였으니 1+4-1 = 4 까지는 수리가 된다. 따라서 현재 위치를 '4'로 변경한다.
3. 배열에서 4보다 작은 값은 전부 무시한다. (1,2,3) 무시.
4. 만약, 4보다 크거나 같은 값이 배열에 존재하면, 그 값으로부터 테이프를 붙인다.
5. '5'에서 테이프를 붙이니 현재 위치는 5+4-1 = 8로 변경된다.
6. 위 과정을 반복하면 테이프를 붙이는 횟수를 알 수 있다.

'''

N,L = map(int, input().split())

location = list(map(int,input().split()))
location.sort()

start = 0
cnt=0
for loc in location:
    if start<loc:
        #테이프 붙이기
        # start+L-1 까지는 자동으로 수리됨.
        start = loc+L-1
        cnt+=1

print(cnt)