'''
[문제 풀기 전 생각할 것]

이 문제를 처음 봤을 때는 예시를 찾는 것 조차 쉽지 않다.

따라서 가장 쉬운 케이스에 해당하는 '불가능'한 경우 부터 찾아나가는게 좋다.

가장 쉽게 생각해서, N = 8인데, M = 8, K= 8을 만들라고 하면 당연히 불가능하다.

즉, 증가수열의 개수와 감소수열의 개수가 N에 종속적이다.

N,M,K 변수가 총 3개인데, N을 기준으로 생각하면, M과 K 두 가지를 고려해야 된다. 따라서,

M과 K가 정해졌을 때, N이 어떤 값일 수 있는지를 생각해본다.

M=8 이고 K=4일 때, N은 몇부터 몇까지 가능할까?

증가하는 수열 8개를 나열하고 감소하는 수열 3개를 나열하면 조건을 만족하고, N= 11이 된다.
ex) 4 5 6 7 8 9 10 11 3 2 1

즉, M과 K가 주어졌을 때, 가장 작은 N은 M+K-1이다.

이번에는 가장 큰 N은 어떻게 될지 생각해보자.

증가하는 수열이 4개고 감소하는 수열이 3개라면 어떻게 나열해야 N이 최대한 커질까?

감소하는 수열 3개씩 묶어서 이를 적절히 배치하는 것이 가장 큰 N을 만들 수 있다.

ex) 3 2 1 / 6 5 4 / 9 8 7 / 12 11 10

이렇게 나열하면, 감소수열의 길이는 3이고, 증가수열의 길이는 3->6->9->12 이렇게 길이가 4가 된다.

즉, N = M*K 라는 값까지 가질 수 있다.

따라서 M+K-1 <= N <= MK 라는 등식이 만족되지 않는다면, 불가능한 경우이므로 -1을 리턴한다.

[아이디어]

우리는 이 과정에서 한 가지 아이디어를 얻을 수 있다.

감소하는 수열의 묶음을 M개 만들면, 반드시 M개의 증가 부분수열을 만들 수 있다는 사실이다. 

만약, N=8, M = 4, K = 3 이라고 해보자.

이 때, 감소하는 수열을 M묶음 만들어보자. (적어도 하나는 감소하는 수열의 길이가 K여야 한다.)

ex) 3,2,1 / 5,4 / 7,6 / 8

자연스럽게 M=4, K=3을 만족하게 된다.

따라서 다음의 알고리즘올 반드시 NMK 수열을 찾을 수 있다.

[알고리즘]

1. 1~N까지 순서대로 나열한다. ex) 1 2 3 4 5 6 7 8
2. 1~N의 숫자를 M묶음으로 나눈다. 이 때, 적어도 하나는 K개의 수열로 이루어져있어야 한다. ex) 1 2 3 / 4 5 / 6 7 / 8
3. 각 묶음의 숫자의 순서를 뒤집는다. ex) 3 2 1 / 5 4 / 7 6 / 8
4. 주어진 수열이 NMK를 만족하는 수열이다.

[TestCase 1]
6 4 2

1 2 / 3 4 / 5 / 6

'''
import math

n,m,k = map(int,input().split())

if m+k-1<= n <= k*m:
    series = list(range(1,n+1))
    result = series[:k][::-1]
    n = n-k
    m = m-1
    s = 0
    e = k
    for i in range(m):
        if m>0:
            r = n%m
            cnt = n //m
            if r>0:
                cnt += 1
            n -= cnt
            m -= 1
            
            s = e
            e = e + cnt
            result += series[s:e][::-1]


    print(' '.join(str(e) for e in result))
else:
    print(-1)