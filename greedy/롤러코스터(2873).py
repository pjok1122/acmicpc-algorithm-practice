'''
[문제 풀기 전 생각할 것]

문제의 예시에서 짐작할 수 있듯이, 모든 칸을 지나는 방법이 존재할 수 있다.

언제 이런 경우가 가능한지 생각해보면 아주 간단하게! 행이나 열이 홀수일 때라는 것을 알 수 있다.

행이 홀수라면, 오른쪽부터 지그재그로 방문하면 되고,
열이 홀수라면, 아래쪽부터 지그재그로 방문하면 된다.

행과 열이 모두 짝수라면 어떻게 될지 생각해보자.

수학적으로 모든 칸을 방문할 수는 없다. 이분그래프를 이용하면 아주 손쉽게 증명이 가능하다.

편의상 4x4로 예를 들어서 생각해보자.

0 1 0 1
1 0 1 0
0 1 0 1
1 0 1 0

그림에서 보듯이, 0의 개수와 1의 개수는 모두 8개다. 그런데, 0에서 출발해서 0으로 도착해야 하니 모든 칸을 방문하는 건 불가능하다.

그럼 어떻게 해야할까? '1'이라고 써있는 칸 하나를 제거하면 나머지는 모두 방문이 가능하다.

0 1 0 1
1 0 X 0
0 1 0 1
1 0 1 0

X라고 써있는 곳을 방문하지 않는다고 해보자. X를 제외한 나머지 칸 모두 방문이 가능함을 어렵지 않게 확인할 수 있다.

0에서 출발해서 0으로 도착해야하니, 0의 개수가 1의 개수보다 1개 많아야 하기 떄문에, 반드시 1이 적힌 칸을 X 표시 해야한다.

즉, 우리는 '1'이 적힌 칸(행+열 ==홀수) 중에서 가장 작은 숫자가 적힌 칸을 찾아야 한다.

가장 작은 숫자가 적힌 칸의 위치를 찾았다고 해서 끝이 아니다.

X의 위치에서 따라서 방문하는 방법이 아주 다양하다. 경로를 정의하기도 어렵다..

이 부분은 '백준'님의 알고리즘을 참고했다.

알고리즘은 다음과 같이 요약된다.

1. 행 줄여나가기
2. 열 줄여나가기.
3. 반드시 2x2 행렬이 되므로, X를 피해서 방문한다.

0은 단순히 칸을 의미하고 X는 방문하지 않아야 할 칸이라고 해보자.

A 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 X 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 B

A의 x좌표+2 보다 X의 x좌표가 크다면 A는 오른쪽으로 출발해서 지그재그로 이동이 가능하다. (x좌표가 같다면 y좌표로 이동 가능 여부를 파악한다.)
B의 x좌표-2 보다 X의 x좌표가 작다면 B는 왼쪽으로 출발하여 지그재그로 이동이 가능하다.

이 두 과정이 끝나면,

A 0 0 X 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 B

이렇게 칸을 줄일 수 있다. A와 B가 더이상 움직일 수 없을 때까지 이 작업을 반복한다면, 행은 반드시 2가 된다.

A 0 0 X 0 0 0 0
0 0 0 0 0 0 0 B

여기서부터는 열에 대해서 다시 적용한다. 이 과정이 끝나면 반드시 행렬은 2x2 사이즈가 된다.

A X
0 B

[알고리즘]

1. 행이 홀수라면, 오른쪽부터 방문하여 전체를 방문한다.
2. 열이 홀수라면, 아래부터 방문하여 전체를 방문한다.
3. 행과 열 모두 짝수라면, 방문하지 않을 위치를 찾는다. (단, 방문하지 않을 위치의 행+열의 값은 홀수이다.)

- 방문하지 않을 위치를 (x,y)라고 하자.
4. 가장 왼쪽 상단의 점 A(0,0)에서 x좌표가 x라는 값보다 작다면 x좌표를 2칸씩 증가시켜 나간다. 단, x가 증가할 때 같은 행에 있는 모든 칸을 방문한다. 
5. 가장 오른쪽 하단의 점 B(r-1,c-1)에서 x좌표가 x+2라는 값보다 크다면 x좌표를 2칸씩 감소시켜 나간다. 단, x가 감소할 때 같은 행에 있는 모든 칸을 방문한다. 

- 위 과정이 끝나면 칸은 2*c 형태이다.
6. 점 A(x1,0)에서 (x,y)의 y좌표보다 2만큼 작다면 오른쪽으로 2칸씩 계속 움직여 나간다. 단 y가 증가할 때 같은 열에 있는 모든 칸을 방문한다.
7. 점 B(x2,c-1)에서 (x,y)의 y좌표보다 2만큼 크다면 왼쪽으로 2칸씩 계속 움직여 나간다. 단 y가 감소할 때 같은 열에 있는 모든 칸을 방문한다.

- 위 과정이 끝나면 칸은 2*2 형태이다.
8. 방문하지 않을 칸 (x,y)가 A의 오른쪽에 있는지 아래에 있는지 판단하여 이동경로를 정한다.
9. A의 움직임과 B의 움직임을 묶어서 출력한다.

[TestCase 1]
3 3
5 1 3
2 4 8
1 1 2

출력 : RRDLLDRR

[TestCase 2]
4 3
1 2 3
4 5 6
7 8 9
10 11 12

출력 : DDDRUUURDDD

[TestCase 3]
4 4
1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 16

출력 : DRRURDDLLLDRRR

[TestCase 4]
4 4
2 2 2 2
2 2 2 2
2 1 2 2
2 2 2 2

출력 : RRRDLLLDDRRURD
'''
import sys

r,c = map(int,sys.stdin.readline().split())
pos = [list(map(int, sys.stdin.readline().split())) for _ in range(r)]

#행이 홀수라면, 오른쪽부터 방문
if r%2==1:
    for _ in range(r//2):
        print('R'*(c-1) + 'D' + 'L'*(c-1) + 'D', end='')
    print('R'*(c-1))

#열이 홀수라면, 아래부터 방문
elif c%2==1:
    for _ in range(c//2):
        print('D'*(r-1) + 'R' + 'U'*(r-1)+'R', end='')
    print('D'*(r-1))
#행과 열이 모두 짝수인 경우,
else:
    Min = 10000

    #방문하지 않을 칸을 찾는다.
    for i in range(r):
        for j in range(c):
            if (i+j)%2==1 and Min > pos[i][j]:
                Min = pos[i][j]
                x = i
                y = j
    
    x1,y1 = 0,0
    x2,y2 = r-1, c-1
    result1=''
    result2=''

    #A에서 출발하여 아래로 2칸 이동이 가능한지 확인
    while(x1+2 <= x):
        x1 +=2
        result1 += 'R'*(c-1) + 'D' + 'L'*(c-1) + 'D'
    
    #B에서 출발하여 위로 2칸 이동이 가능한지 확인 (결국 A가 이동하는 것이므로, 이동방법은 역순으로 작성.)
    while(x2-2 >= x):
        x2 -=2
        result2 += 'D'+'L'*(c-1)+'D'+'R'*(c-1)

    #행이 2인 상황이 됐으므로, 열에 대해서 적용.
    while(y1+2 <= y):
        y1 +=2
        result1 += 'DRUR'
    
    while(y2-2 >= y):
        y2 -=2
        result2 = 'RURD' + result2

    #행렬이 2x2인 상황이 되었음. A의 위치에서 오른쪽에 '방문X' 가 있는지, 아래쪽에 있는지만 확인하면 된다.

    if x1+1 == x:
        result1 += 'RD'
    elif y1+1 ==y:
        result1 += 'DR'
    
    print(result1+result2)